# 计算机图形学

## 一  绪论

1.计算机图形学是利用计算机研究图形的**表示、生成、处理、显示**的学科。

2.图形与图像：
图像指计算机内以位图(Bitmap)形式存在的灰度信息。
图形含有几何属性，更强调场景的几何表示，是由场景的几何模型和景物的物理属性共同组成的。

3.计算机中重现真实世界的场景叫做**真实感绘制**

4.图形输出包括**图形的显示和图形的绘制**，图形显示指的是在屏幕上输出图形
图形绘制通常指把图形画在纸上，也称硬拷贝，打印机和绘图仪是两种最常用的硬拷贝设备。

5.高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置。

6.电子束要到达屏幕的边缘时，偏转角度就会增大。到达屏幕最边缘的偏转角度被称为最大偏转角

7.刷新一次是指电子束从上到下扫描一次的过程

8.普通的显象管采用的都是荫罩式显象管，显象管的表面呈略微凸起的球面状，故称之为“球面管”。而柱面显象管采用荫栅式结构，它的表面在水平方向仍然略微凸起，但是在垂直方向上却是笔直的，呈圆柱状，故称之为“柱面管”

9.LCD显示器的优点：
外观小巧精致，厚度只有6.5~8cm左右、不会产生CRT那样的因为刷新频率低而出现的闪烁现象、工作电压低，功耗小，节约能源没有电磁辐射、对人体健康没有任何影响

10.最常用的图形输入设备就是基本的计算机输入设备——键盘和鼠标

11.◦跟踪球和空间球都是根据球在不同方向受到的推或拉的压力来实现定位和选择。数据手套则是通过传感器和天线来获得和发送手指的位置和方向的信息。这几种输入设备在虚拟现实场景的构造和漫游中特别有用

12.主要内容：
绪论
光栅图形学
扫描转换、裁减、反走样、消影
几何造型
曲线曲面造型、实体造型
真实感图形学
Phong模型、光线跟踪、辐射度算法

## 二  光栅图形学

1.什么是光栅图形学：光栅显示器 -> 图形光栅化、光栅化图形的处理

2.直线段的扫描转换算法：DDA、中点画线法、Bresenham算法

3.DDA算法

```c++
void DDALine(int x0,int y0,int x1,int y1,int color)     
     
     int x；							
	float dx, dy, y, k;						
	dx, = x1-x0, dy=y1-y0;					   
	k=dy/dx, y=y0;	 					   
	for (x=x0; x<=x1, x++)					   
	  drawpixel (x, int(y+0.5), color);		   
	   y=y+k;
     
  

```

4.中点画线法

```c++
void Midpoint Line (int x0,int y0,int x1, int y1,int color)
     {   int a, b, d1, d2, d, x, y;
    a=y0-y1, b=x1-x0, d=2*a+b;
    d1=2*a, d2=2* (a+b);
    x=x0, y=y0;
    drawpixel(x, y, color);
    while (x<x1)
    { if (d<0)  {x++, y++, d+=d2; }
     else       {x++, d+=d1;}
     drawpixel (x, y, color);
     }  /* while */
 } /* mid PointLine */

```

5.Bresenham算法

```c++
void Bresenhamline (int x0,int y0,int x1, int y1,int color)
{   int x, y, dx, dy;
    float k, e;
    dx = x1-x0, dy = y1- y0, k=dy/dx; 
    e=-0.5, x=x0, y=y0;
    for (i=0; idx; i++)
    {    drawpixel (x, y, color);
          x=x+1，e=e+k;
          if (e0)
          { y++, e=e-1;}
    }
  }

```

6.圆弧的扫描转换算法

```c++
MidPointCircle(int r int color)
{	int x,y;
     float d;
     x=0; y=r; d=1.25-r;
     circlepoints (x,y,color); //显示圆弧上的八个对称点
     while(x<=y)
    {	if(d<0)   	d+=2*x+3;
		else    { d+=2*(x-y)+5;  y--;}
x++;
circlepoints (x,y,color);
	}
}

```

7.多边形的扫描转换与区域填充

多边形有两种重要的表示方法：顶点表示和点阵表示。
多边形的扫描转换:把多边形的顶点表示转换为点阵表示。
区域可采用内点表示和边界表示两种表示形式。
区域填充:指先将区域的一点赋予指定的颜色，然后将该颜色扩展到整个区域的过程。

8.扫描线算法
基本思想：
按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的象素，即完成填充工作。
对于一条扫描线填充过程可以分为四个步骤：
求交、排序、配对、填色

9.活性边表(AET)：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中
结点内容
 x：当前扫描线与边的交点坐标
△x：从当前扫描线到下一条扫描线间x的增量（1/k）
ymax：该边所交的最高扫描线号ymax

新边表（NET）：
	存放在该扫描线第一次出现的边。若某边的较低端点为ymin，则该边就放在扫描线ymin的新边表中

10.区域填充的递归算法

```c++
void BoundaryFill4(int x,int y,int boundarycolor,int newcolor)
{   int color;
     color=getpixel(x,y);
	if(color!=newcolor && color!=boundarycolor)
	{	drawpixel(x,y,newcolor);
		BoundaryFill4 (x,y+1, boundarycolor,newcolor);
		BoundaryFill4 (x,y-1, boundarycolor,newcolor);
		BoundaryFill4 (x-1,y, boundarycolor,newcolor);
		BoundaryFill4 (x+1,y, boundarycolor,newcolor);
    }
}

```

11.区域填充的扫描线算法

算法步骤：
首先填充种子点所在扫描线上的位于给定区域的一个区段
然后确定与这一区段相连通的上、下两条扫描线上位于给定区域内的区段，并依次保存下来。
反复这个过程，直到填充结束。

(1)初始化：堆栈置空。将种子点（x，y）入栈。
(2)出栈：若栈空则结束。否则取栈顶元素（x，y），以y作为当前扫描线。
(3)填充并确定种子点所在区段：从种子点（x，y）出发，沿当前扫描线向左、右两个方向填充，直到边界。分别标记区段的左、右端点坐标为xl和xr。
(4)并确定新的种子点：在区间[xl，xr]中检查与当前扫描线y上、下相邻的两条扫描线上的象素。若存在非边界、未填充的象素，则把每一区间的最右象素作为种子点压入堆栈，返回第（2）步。
    上述算法对于每一个待填充区段，只需压栈一次；因此，扫描线填充算法提高了区域填充的效率。



```c++
Typedef   struct {
     int x,int y;
     }seed;
Void ScanLineFill4(int x,int y,colorRef oldcolor,colorRef  newcolor)
{
    int xl,xr,i;
   bool  spanneedfill;
   stack.empty();
   pt.x=x;pt.y=y;
  stack.push(pt);
  while(!  Isstack.empty())
      {
            pt=stack.pop();
            x=pt.x;y=pt.y;
       while(getpixel(x,y)==oldcolor)///向右填充
       {
               drawpixel(x,y,newcolor);
               x++;
      }
       xr=x-1;
       x=pt.x-1;
       while(getpixel(x,y)==oldcolor)///向左填充
      {
             drawpixel(x,y,newcolor)
             x--;
      }
     xl=x+1;
           //处理上一条扫描线
    x=xl;
    y=y+1;
  while(x<=xr)
   {
        spanneedfill=false;
       while(getpiexl(x,y)==oldcolor)
        {
               spanneedfill=true;
              x++;
        }
       if(spanneedfill)
        { 
             pt.x=x-1;pt.y=y;
            stack.push(pt);
        spanneedfill=false;
}
While(getpixel(x,y)!=oldcolor&&x<=xr)    
            x++;
}
////处理下一条扫描线
X=xl;
Y=y-2;
While(x<=xr)
{
    spanneedfill=false;
   while(getpixel(x,y)==oldcolor)
    {
          spanneedfill=false; 
          x++;
}
        if(spanneedfill)
      {
          pt.x=xl-1 ;      pt.y=y;
         stack.push(pt);
        spanneedfill=false;
     }
     while(getpixel(x,y)!==oldcolor&&x<=xr)
         x++;
}


```

12.字库：字库中存储了每个字符的形状信息，字库分为矢量型和点阵型两种。

13.直线段裁剪：Cohen-Sutherland、中点分割算法、梁友栋－Barskey

14.Cohen-Sutherland裁剪 

编码方式（左、右、上、下）



•基本思想：对于每条线段P1P2分为三种情况处理分为三种情况处理:

（1）若P1P2完全在窗口内，则显示该线段P1P2简称“取”之。

（2）若P1P2明显在窗口外，则丢弃该线段，简称“弃”之。

（3）若线段不满足“取”或 “弃”的条件，则在交点处把线段分为两段。其中一段完全在窗口外，可弃之。然后对另一段重复上述处理。

15.中点分割裁剪算法

•基本思想：

 与前一种Cohen-Sutherland算法一样首先对线段端点进行编码，并把线段与窗口的关系分为三种情况:

–全在、完全不在和线段和窗口有交。对前两种情况，进行一样的处理。

–对于第三种情况，用中点分割的方法求出线段与窗口的交点。

16.梁友栋－Barsky算法

•参数化形式写出裁剪条件：xl <= x1+uのx <=xr    yb <= y1 + uのx <= yt

```c++
void LB_LineClip(x1,y1,x2,y2,XL,XR,YB,YT)
float x1,y1,x2,y2,XL,XR,YB,YT;
{	float dx,dy,u1,u2;
	u1=0;u2=1 ;	dx =x2-x1;dy =y2-y1;
   if(ClipT(-dx,x1-XL,&u1,&u2)
     if(ClipT(dx,XR-x1, &u1,&u2)
if(ClipT(-dy,y1-YB, &u1,&u2)
         if(ClipT(dy,YT-y1, &u1,&u2)
  {	displayline(x1+u1*dx,y1+u1*dy, x1+u2*dx,y1+u2*dy)
		return;
    	   }
 }
bool ClipT(p,q,u1,u2)
float p,q,*u1,*u2;
{  float r;
if(p<0)
{	r=q/p;
	if(r>*u2)  return FALSE;
	else if(r>*u1)
	{ 	*u1=r;	return TRUE;	}
}else if(p>0)
{	r=p/q;
	if(r<*u1)return FALSE;
	else if(r<*u2)
    {	*u2=r;return TRUE;}
}
   else if(q<0) return FALSE;
   return TRUE;
}


```

17.多边形裁剪

18.反走样：用离散量表示连续量引起的失真现象称之为走样，用于减少或消除这种效果的技术称为反走样

（1）提高分辨率：•增加分辨率虽然简单，但是不经济的方法，有物理上的困难

•而且它也只能减轻而不能消除锯齿问题

（2）区域采样：–每个象素是一个具有一定面积的小区域，将直线段看作具有一定宽度的狭长矩形。当直线段与象素有交时，求出两者相交区域的面积，然后根据相交区域面积的大小确定该象素的亮度值。

象素的亮度与相交区域的面积成正比，而与相交区域落在象素内的位置无关，这仍然会导致锯齿效应。
直线条上沿理想直线方向的相邻两个象素有时会有较大的灰度差。

（3）加权区域采样：使相交区域对象素亮度的贡献依赖于该区域与象素中心的距离
当直线经过该象素时，该象素的亮度F是在两者相交区域A’上对滤波器（函数w）进行积分的积分值

19.消隐：•投影变换失去了深度信息，往往导致图形的二义性

•要消除二义性，就必须在绘制时消除被遮挡的不可见的线或面，习惯上称作消除隐藏线和隐藏面，简称为**消隐**。

20.画家算法原理：

（1）.画家算法的核心在于对场景中的多边形进行深度排序。即根据多边形与视点的距离，将它们分为不同的优先级，距离视点近的多边形优先级高，距离视点远的多边形优先级低。

（2）在完成深度排序后，画家算法按照优先级从低到高的顺序绘制多边形。即先绘制距离视点远的多边形，后绘制距离视点近的多边形。

21.种子填充4连通和8连通

- **4连通**：在二维像素阵列中，从区域内任意一点出发，仅可通过上、下、左、右四个方向到达区域内的任意像素。这种连接方式形成的区域称为4连通区域。
- **8连通**：同样在二维像素阵列中，从区域内任意一点出发，可通过上、下、左、右、左上、左下、右上、右下八个方向到达区域内的任意像素。这种连接方式形成的区域称为8连通区域。

22.种子填充算法步骤

一、确定种子点
选择方式：在算法开始之前，需要先确定一个或多个种子点。这些种子点位于需要填充的封闭区域内，可以是区域的任何一点。通常情况下，可以通过人工交互来指定种子点，也可以使用自动化的方法（如算法自动检测区域内的某个点）来选择。
二、初始化
设置数据结构：根据算法的实现方式（如递归、栈等），初始化相应的数据结构。如果使用栈来实现，则需要将栈置空。
标记像素：将所有像素标记为未分割或未填充状态，以便后续跟踪和处理。
三、将种子点加入栈中（或进行初始处理）
将选定的种子点加入到栈中（如果使用栈实现），或者进行其他形式的初始处理（如直接处理种子点）。同时，记录该点的颜色值或其他相关信息。
四、迭代填充过程
取出栈中元素：从栈中取出一个点（如果使用栈实现），或者选择下一个待处理的点（如果采用其他方式）。
填充当前点：将该点的颜色值更改为目标填充颜色，表示该点已被填充。
检查相邻点：找到当前点的相邻点（根据四连通或八连通规则），并检查它们是否满足填充条件（如未被填充、位于封闭区域内等）。
加入栈中：如果相邻点满足填充条件，则将其加入栈中以便后续处理，或者直接处理该相邻点（取决于算法的具体实现）。
五、重复迭代过程
重复上述迭代填充过程，直到栈为空（如果使用栈实现）或没有更多的相邻点满足填充条件为止。
六、填充完成
当栈为空或没有更多的相邻点需要填充时，表示封闭区域已经被完全填充。此时，算法结束。
七、显示结果
将填充后的图像显示出来，或者将填充后的区域用指定的颜色绘制出来。这一步骤是可选的，取决于算法的应用场景和目的。
注意事项
在实现种子填充算法时，需要注意选择合适的相似度度量方法和阈值（如果涉及相似度比较的话），以及避免出现死循环或者过度分割的情况。
种子填充算法可以通过一些优化技巧来提高分割效率和准确性，例如并行化处理、多种子分割等。
根据具体的实现方式和应用场景，种子填充算法的实现细节可能会有所不同。例如，在实现时可以选择使用递归方式或栈方式来进行迭代填充过程。递归方式实现简单但可能会导致栈溢出等问题；而栈方式则更为稳定但需要手动管理栈的数据结构。

## 三 几何造型技术

### 1.描述物体的三维模型有三种:

​	 线框模型、曲面模型和实体模型

### 2.曲线二阶参数连续和几何连续的区别和联系

- **C2连续**：更侧重于曲线在连接点处的精确匹配，包括切线方向和曲率大小的完全相等。
- **G2连续**：更侧重于曲线在连接点处视觉上的光滑性，允许曲率大小有一定差异，但要求曲率方向一致。

### 3.曲线和曲面的几何方法

曲线：

- **定义**：参数方程是一种通过引入一个或多个参数来描述曲线上点的方法。这些参数通常与时间或某种度量相关，通过改变参数的取值范围，可以得到曲线上的不同点。
- **示例**：对于平面上的曲线，可以使用参数方程如 *x*=*f*(*t*),*y*=*g*(*t*)，其中 *t* 是参数，*f*(*t*) 和 *g*(*t*) 是关于 *t* 的函数。在三维空间中，曲线参数方程可以扩展为 *x*=*f*(*t*),*y*=*g*(*t*),*z*=*h*(*t*)。

曲面：

- **定义**：与曲线类似，曲面的参数方程通过引入两个或多个参数来描述曲面上的点。这些参数通常与时间或某种度量相关，通过改变参数的取值范围，可以得到曲面上的不同点。
- **示例**：对于三维空间中的曲面，可以使用参数方程如 *x*=*f*(*u*,*v*),*y*=*g*(*u*,*v*),*z*=*h*(*u*,*v*)，其中 *u* 和 *v* 是参数，*f*(*u*,*v*)、*g*(*u*,*v*) 和 *h*(*u*,*v*) 是关于 *u* 和 *v* 的函数。

### 4.贝塞尔曲线的优缺点

优点

1. **精度高**：贝塞尔曲线是由多个控制点按特定比例连接而成的，这使得曲线的形态可根据实际需要进行灵活调整。贝塞尔曲线的流畅性和精度较高。
2. **灵活性强**：控制点的位置和数量可以任意设置，形成的曲线形状和曲率都可任意调整，这使得贝塞尔曲线在设计时更具有灵活性，可以创建各种形状的曲线和曲面，方便了设计师的创意表达。
3. **易于计算、存储和绘制**：贝塞尔曲线的计算、存储和绘制都比较简单，计算速度快。用贝塞尔曲线描述的对象可以被表示为一系列的点和线，而这些数据可以方便地存储在计算机中。
4. **有效的变形**：贝塞尔曲线允许使用控制点自由地调整曲线形状，这使得曲线可以实时地变形，可以很方便地进行修改和编辑，充分满足了设计时的需求。

缺点

1. **难以控制密度**：由于贝塞尔曲线上的点和线可以任意建立，所以对于不熟悉建模的人来说，会容易出现点密度过高或密度过低的问题，从而给编辑和建模带来极大的困难。
2. **难以控制光滑度**：在某些情况下，两条曲线的相邻控制点越远，曲线的光滑度就越高。但这也可能导致在某些情况下，贝塞尔曲线出现光滑度不够、角度变化较大等问题，难以满足特定的使用需求。
3. **曲线需要更多的控制点**：与其他一些曲线表示方法（如B样条曲线）相比，贝塞尔曲线需要更多的控制点来描述同样的曲线形状，这使得绘制和编辑曲线时更加繁琐。
4. **不适用于处理复杂曲线**：虽然贝塞尔曲线适用于处理各种类型的二维和三维曲线、曲面，但是对于一些特别复杂的曲线，例如纹理较多或具有高度非线性的曲线，使用贝塞尔曲线并不是最佳选择。
5. **不能作局部修改**：改变一个控制点的位置会对整条曲线产生影响，不易控制形状。
6. **逼近效果不好**：曲线离特征多边形较远时，逼近效果不理想。

B样条曲线的优缺点

优点

1. **多项式次数可独立于控制点数目**：B样条曲线的一个显著优点是它的多项式次数可以独立于控制点的数目，这使得在控制点数量较多时，仍然可以保持较低的多项式次数，从而简化计算。
2. **允许局部调整**：B样条曲线允许对曲线的局部进行控制，这意味着修改一个控制点只会影响曲线的一部分，而不会对整个曲线产生影响，这使得在编辑和调整曲线时更加灵活和方便。
3. **更逼近多边形**：与贝塞尔曲线相比，B样条曲线能够更好地逼近控制多边形，这使得在需要精确控制曲线形状时，B样条曲线是一个更好的选择。
4. **造型的灵活性**：B样条曲线具有凸包性、几何不变性和变差缩减性等性质，这使得它在造型设计上具有更高的灵活性。

缺点

1. **比贝塞尔曲线更复杂**：B样条曲线的计算和实现相对贝塞尔曲线来说更为复杂，需要更多的数学知识和计算资源。
2. **控制点需要合理分布**：虽然B样条曲线允许局部调整，但如果控制点的分布不合理，仍然可能导致曲线形状的不理想。

### 5.参数方程，隐式/显示的优缺点

参数表示的优点：

（1）以满足几何不变性的要求。

（2）有更大的自由度来控制曲线、曲面的形状

（3）对曲线、曲面进行变换，可对其参数方程直接进行几何变换。

（4）便于处理斜率为无穷大的情形，不会因此而中断计算。

（5）便于用户把低维空间中曲线、曲面扩展到高维空间去。

（6）规格化的参数变量t∈[0, 1]，使其相应的几何分量是有界的，而不必用另外的参数去定义边界。

（7）易于用矢量和矩阵表示几何分量，简化了计算。

•显式或隐式表示存在下述问题：

（1）与坐标轴相关；

（2）会出现斜率为无穷大的情形(如垂线)；

（3) 不便于计算机编程。

### 6.曲线曲率 k的定义、几何意义

曲线的曲率（curvature）是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏离直线的程度。在数学上，它用于量化曲线在某一点的弯曲程度。曲率越大，表示曲线的弯曲程度越大；反之，曲率越小，表示曲线越接近直线。

## 四  真实感图形学

### 1.颜色是外来的光刺激作用于人的视觉器官而产生的主观感觉，影响的因素有：

物体本身
光源
周围环境
观察者的视觉系统

### 2.法向量与方向向量的关系

- 法向量与直线（或直线所在平面的方向向量）垂直。这是法向量与方向向量之间最直接的关系。在三维空间中，如果已知直线的方向向量和某平面的法向量，可以通过它们的点积（内积）来判断直线与平面的位置关系。如果点积为0，则直线与平面垂直。

### 3.漫反射模型参数意义

1. 光源参数

- **光源强度（I）**：表示光源的发光强度，通常是一个标量或颜色向量，表示光源在特定波长或所有波长上的辐射能量。
- **光源位置/方向（L）**：对于点光源，需要指定光源在三维空间中的位置；对于平行光（如太阳光），则只需要指定光线的方向。光源位置或方向通常表示为三维向量。

2. 物体表面参数

- **反射系数（K或Kd）**：也称为材质的反射率或漫反射系数，是一个介于0和1之间的数值（或在颜色空间中，为介于黑色和白色之间的颜色向量）。它表示物体表面对光线的反射能力，即有多少比例的光线被物体表面反射出来。
- **表面法线（N）**：表示物体表面在某一点的法线方向，是垂直于表面该点的向量。在漫反射模型中，表面法线用于计算光线与表面的夹角，进而影响反射光线的强度。

3. 夹角参数

- **入射角（θ）**：光线与表面法线之间的夹角。在漫反射模型中，反射光线的强度与这个夹角的余弦值成正比，这符合兰伯特定律（Lambert's Law）。

### 4.颜色模型

1. **RGB颜色模型**
   - **基本原理**：RGB（Red, Green, Blue）颜色模型基于红、绿、蓝三种基本颜色光的叠加来产生各种颜色。这三种颜色光被称为加性原色，即它们叠加在一起会产生更亮的颜色。
   - **使用领域**：RGB颜色模型广泛应用于彩色阴极射线管（CRT）、液晶显示器（LCD）等彩色光栅图形显示设备中。此外，扫描仪也使用RGB颜色模型来表示原稿的颜色。
   - **优缺点**：RGB颜色模型的优点是直观、容易理解，且能够产生丰富的颜色。然而，其缺点是R、G、B三个分量是高度相关的，颜色空间的均匀性较差。
2. **CMYK颜色模型**
   - **基本原理**：CMYK（Cyan, Magenta, Yellow, Black）颜色模型基于青、品红、黄三种基本油墨的叠加以及黑色的加入来产生各种颜色。这种模型被称为减色模型，因为当油墨叠加时，反射到人眼的光会越来越少，从而产生不同的颜色。
   - **使用领域**：CMYK颜色模型广泛应用于印刷工业中，用于表示印刷品的颜色。
   - **优缺点**：CMYK颜色模型的优点是能够准确地表示印刷品的颜色，但其色域较RGB颜色模型小，且颜色表示与设备和印刷过程紧密相关。
3. **HSV颜色模型**
   - **基本原理**：HSV（Hue, Saturation, Value）颜色模型基于人类对颜色的心理感受来构建。其中，H表示色调（Hue），S表示饱和度（Saturation），V表示亮度（Value）。HSV颜色模型通过调整这三个参数来改变颜色。
   - **使用领域**：HSV颜色模型在图像处理中常用于颜色选择和调整，因为它更符合人类的视觉感受。
   - **优缺点**：HSV颜色模型的优点是直观且易于调整颜色，但其计算相对复杂，且在某些情况下可能无法准确表示所有颜色。
4. **YUV颜色模型**
   - **基本原理**：YUV颜色模型是一种用于电视信号表示的颜色模型。它利用人眼对亮度信号变化敏感，对色度信号变化不敏感的特点来降低彩色图像所需的存储容量。在YUV模型中，Y表示亮度分量，U和V表示色度分量。
   - **使用领域**：YUV颜色模型广泛应用于视频压缩和传输领域。
   - **优缺点**：YUV颜色模型的优点是能够有效地降低彩色图像的存储和传输带宽需求，但其颜色表示可能与原始RGB颜色模型存在一定差异。

### 5.phone光照模型

一、基本概述

Phong光照模型仅考虑物体对直接光照的反射作用，认为环境光是常量，没有考虑物体之间相互的反射光，物体间的反射光仅用环境光表示。该模型属于简单光照模型，仅考虑光源直接照射在景物表面所产生的光照效果，并且景物表面通常被假定为不透明，且具有均匀反射率。

二、光照组成

Phong光照模型将光照分解为以下三个部分：

1. **环境光（Ambient）**：环境光是没有方向的光，它来自四面八方，对物体表面的影响是均匀的。环境光的计算通常是将环境光颜色乘以环境光强度。
2. **漫反射（Diffuse）**：漫反射是光线在粗糙表面发生的反射，反射光线会向各个方向均匀散射。漫反射的强度取决于光线入射方向与表面法线方向的夹角。计算漫反射时，通常使用这两个方向的点积，并乘以漫反射光颜色和漫反射光强度。
3. **镜面反射（Specular）**：镜面反射是光线在光滑表面发生的反射，反射光线会按照“入射角等于反射角”的规律进行。镜面反射的强度取决于观察方向与反射光方向的夹角，夹角越小，反射光越集中，镜面反射效果越明显。计算镜面反射时，通常先求出反射光方向，然后计算观察方向与反射光方向的夹角，并对该夹角进行某种变换（如取幂次）以增强效果，最后乘以镜面反射光颜色和镜面反射光强度。

## 五 图形标准

1.OpenGL的特点

（1）工业标准，是工业界图形应用编程接口标准，广泛应用于各种场合。

（2）跨平台性，几乎能在所有的主流平台和操作系统上运行

（3）易用性，OpenGL具有结构良好的，直观易用的API，少数代码实现强大功能，无须关注底层细节。

（4）出色的编程特性，具有充分的独立性

（5）详细的文档，在网络上可以找到很多OpenGL的示范程序，有详细的教材和教程

2.OpenGL的glfinish和glflash的区别

- **`glFinish()`**：此函数会阻塞调用线程，直到命令队列中的所有OpenGL命令都执行完毕，并且图形硬件完成了所有相关操作。这意味着在调用`glFinish()`后，程序会等待直到所有之前提交的命令都执行完成，然后才继续执行后续代码。因此，`glFinish()`可以用于确保之前的渲染操作已经完成。
- **`glFlush()`**：此函数会强制将命令队列中的所有OpenGL命令立即提交给图形硬件执行，但它不会等待这些命令执行完毕。它只是确保命令被发送到了图形硬件并开始执行，然后函数会立即返回，OpenGL可以继续执行后续的代码，而不必等待命令执行完成。

3.OpenGL中绘制1度折线

| **GL_POINTS**     | **一系列的孤立点**                               |
| ----------------- | ------------------------------------------------ |
| GL_LINES          | 每两点相连成线段                                 |
| GL_POLYGON        | 简单，凸多边形的边界                             |
| GL_TRIANGLES      | 三点相连成一个三角形                             |
| GL_QUADS          | 四点相连成一个四边形                             |
| GL_LINE_STRIP     | 顶点相连成一系列线段                             |
| GL_LINE_LOOP      | 顶点相连成为一系列线段，连接最后一个点与第一个点 |
| GL_TRIANGLE_STRIP | 相连成三角形带                                   |
| GL_TRIANGLE_FAN   | 相连成三角形扇形                                 |
| GL_QUAD_STRIP     | 相连成四边形带                                   |

```c++
glRotatef(-1, 0, 0, 1);
vertex = cos(-1 * M_PI / 180); // 将度转换为弧度
vertex = sin(-1 * M_PI / 180);
glVertex2f(vertex, vertex);
```

